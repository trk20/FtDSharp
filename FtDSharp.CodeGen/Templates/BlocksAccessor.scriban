// <auto-generated/>
// Generated by FtDSharp.CodeGen - do not edit manually
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using FtDSharp.Facades;

namespace FtDSharp
{
    /// <summary>Per-frame lazy cache that resets automatically each tick.</summary>
    internal sealed class FrameCache<T>
    {
        private readonly Func<T> _factory;
        private long _frame = -1;
        private T? _value;

        public FrameCache(Func<T> factory) => _factory = factory;

        public T Value
        {
            get
            {
                var currentFrame = Game.TicksSinceStart;
                if (_frame != currentFrame)
                {
                    _frame = currentFrame;
                    _value = _factory();
                }
                return _value!;
            }
        }
    }

    /// <summary>Static accessor for blocks on the current construct. Caches results per script update.</summary>
    public static class Blocks
    {
        private static readonly FrameCache<IReadOnlyList<IBlock>> _all = new(() =>
            (ScriptApi.Context?.Self?.GetAllBlocks() ?? Enumerable.Empty<IBlock>()).ToList());

        /// <summary>Get all blocks on the main construct (including subconstructs).</summary>
        public static IReadOnlyList<IBlock> All => _all.Value;

        /// <summary>Get all blocks of a specific type.</summary>
        public static IEnumerable<T> OfType<T>() where T : IBlock => All.OfType<T>();

        /// <summary>Get a block by its unique ID.</summary>
        public static IBlock? ById(int uniqueId) => All.FirstOrDefault(b => b.UniqueId == uniqueId);

{{~ for block in blocks ~}}
{{~ if block.has_store && !block.is_interface_store ~}}
        private static readonly FrameCache<IReadOnlyList<{{ block.interface_name }}>> {{ block.field_name }} = new(() =>
        {
            var store = ScriptApi.Context?.BlockTypeStorage?.{{ block.store_property_name }};
            if (store?.Blocks == null) return Array.Empty<{{ block.interface_name }}>();
{{~ if block.is_weapon || block.is_turret ~}}
            var allConstruct = ScriptApi.Context?.RawAllConstruct;
            if (allConstruct == null) return Array.Empty<{{ block.interface_name }}>();
{{~ end ~}}
            var result = new List<{{ block.interface_name }}>(store.Blocks.Count);
            foreach (var block in store.Blocks)
            {
{{~ if block.is_weapon || block.is_turret ~}}
                if (block != null) result.Add(FacadeCache.GetOrCreate<{{ block.class_name }}Facade>(block, () => new {{ block.class_name }}Facade(block, allConstruct)));
{{~ else ~}}
                if (block != null) result.Add(FacadeCache.GetOrCreate<{{ block.class_name }}Facade>(block, () => new {{ block.class_name }}Facade(block)));
{{~ end ~}}
            }
            return result;
        });
{{~ else if block.has_store && block.is_interface_store ~}}
        private static readonly FrameCache<IReadOnlyList<{{ block.interface_name }}>> {{ block.field_name }} = new(() =>
        {
            var store = ScriptApi.Context?.BlockTypeStorage?.{{ block.store_property_name }};
            if (store?.Blocks == null) return Array.Empty<{{ block.interface_name }}>();
{{~ if block.is_weapon || block.is_turret ~}}
            var allConstruct = ScriptApi.Context?.RawAllConstruct;
            if (allConstruct == null) return Array.Empty<{{ block.interface_name }}>();
{{~ end ~}}
            var result = new List<{{ block.interface_name }}>();
            foreach (var block in store.Blocks)
            {
{{~ if block.is_weapon || block.is_turret ~}}
                if (block is {{ block.game_type_full_name }} concrete) result.Add(FacadeCache.GetOrCreate<{{ block.class_name }}Facade>(concrete, () => new {{ block.class_name }}Facade(concrete, allConstruct)));
{{~ else ~}}
                if (block is {{ block.game_type_full_name }} concrete) result.Add(FacadeCache.GetOrCreate<{{ block.class_name }}Facade>(concrete, () => new {{ block.class_name }}Facade(concrete)));
{{~ end ~}}
            }
            return result;
        });
{{~ else ~}}
        private static readonly FrameCache<IReadOnlyList<{{ block.interface_name }}>> {{ block.field_name }} = new(() => All.OfType<{{ block.interface_name }}>().ToList());
{{~ end ~}}
        /// <summary>Get all {{ block.class_name }} blocks (cached per update).</summary>
        public static IReadOnlyList<{{ block.interface_name }}> {{ block.plural_name }} => {{ block.field_name }}.Value;

{{~ end ~}}
    }
}
